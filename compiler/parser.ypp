/*
    Parser of QBASIC to build Abstruct Syntax Tree
    * Copyright (C) 2009-2010 Thomas Larsen and Pedro Sá.
	* Copyright (C) 1995-2005 Marc-Oliver Ihm.
    * Copyright (C) 2012  microcai <microcai@fedoraproject.org>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 3 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
%skeleton "lalr1.cc"
%define namespace qb

%{

/* Include main header file. */
#include "qbc.h"
#include "parser.hpp"
#include <boost/make_shared.hpp>
#include <boost/concept_check.hpp>

extern	StatementAST * program;


extern int yylex(qb::parser::semantic_type * yylval_param );

//extern int yylex_destroy(void);
//extern void yyerror (char *msg);
extern int yylineno;

#define debug printf

/* Types of functions. */
enum {
   ftNONE, ftNUMBER, ftSTRING
};


/* Global variables. */
std::string current_function;  /* name of currently parsed function */
int in_loop = 0;                /* in loop? */

/* Local variables. */
int continue_corrections = 0;   /* continue corrections */
int unclosed_dos = 0;           /* unclosed "if" count */
int unclosed_fors = 0;          /* unclosed "for" count */
int unclosed_ifs = 0;           /* unclosed "if" count */
int unclosed_repeats = 0;       /* unclosed "repeat" count */
int unclosed_subs = 0;          /* unclosed subroutine count */
int unclosed_switches = 0;      /* unclosed "switch" count */
int unclosed_whiles = 0;        /* unclosed "while" count */
bool until_eol = false;          /* read to end of line? */
bool useDefautSubMain = false;	/* shall we treat the while file as an sub main ? */

/* Sanity check routine. */
void not_inside_loop_or_conditional (char *what) {
   /* Display an error if necessary. */
   if ((unclosed_dos || unclosed_fors || unclosed_repeats || unclosed_whiles) || (unclosed_ifs || unclosed_switches)) {
      if ((unclosed_dos || unclosed_fors || unclosed_repeats || unclosed_whiles) && (unclosed_ifs || unclosed_switches)) {
         debug ("cannot %s inside a loop, \"if\" statement, or \"switch\" construct", what);
      }
      else if (unclosed_dos || unclosed_fors || unclosed_repeats || unclosed_whiles) {
         debug ("cannot %s inside a loop", what);
      }
      else if (unclosed_ifs || unclosed_switches) {
         debug ("cannot %s inside an \"if\" statement or \"switch\" construct", what);
      }
   }

   /* Return. */
   return;
}

void qb::parser::error(const parser::location_type& loc, const std::string& msg)
{
	std::cerr << msg << " at line " << yylineno << std::endl ;
	exit(1);
}


%}

%union {
	char *string;         /* quoted string */
	char *symbol;         /* general symbol */
	double number;        /* double number */
	int separator;        /* separator */
	ExprTypeAST *  exprtype;

	NumberExprAST* number_expression;
    VariableRefExprAST*varable_ref;	
	
	StatementAST* statement;
	StatementAST* statement_list;
	AssigmentAST*variable_assignment;
	IFStmtAST * if_clause;
	
	WhileLoopAST* while_loop;
	
	VariableDimAST*dim_list;
	FunctionDimAST	 *function_definition;

	PrintIntroAST *print_intro;
	PrintListAST * print_list;
	std::string 	*cppstring;
}

%token  tEOPROG

// 操作符
%left tOR
%left tAND
%right tNOT
%left tNEQ
%left tGEQ
%left tLEQ
%left tLTN
%left tGTN
%left tEQU
%left '-' '+'
%left '*' '/' tMOD
%right UMINUS UPLUS
%left tPOW

%nonassoc tDREF
%nonassoc '.'

//关键字

%token tAS
%token tSUB
%token tSUBEND

%token tFUNCTION
%token tFUNCTIONEND
%token tDIM tLET tPRINT

%token tNEWLINE


// 内置数据类型
%token tLONG 

// 数据 , 标识符, 变量名, 函数名, 等等
%token tID tInteger

%%

program: lines tEOPROG {
			if(useDefautSubMain){
				debug("program ended\n");
				//program = new DefaultMainFunctionAST( $1 );
			}else{
				//program = $1;
				debug("module ended\n");
			}
			YYACCEPT;
		}
		;

lines : lines line
	| line ;

line :   statements tNEWLINE
	| tID ':' statements tNEWLINE ;
	| tInteger ':' statements tNEWLINE ;

statements : statements ':' statement
		| statement
		;

statement : printstatement
		| tDIM dimlist
		| tSUB tID '(' dimlist ')'
		| tSUBEND
		| tFUNCTION tID '(' dimlist ')' tAS type
		| tFUNCTION tID '(' dimlist ')'
		| tFUNCTIONEND
		| assigment
		;


assigment: varref tEQU expression
		| tLET varref tEQU expression
		;

type: tLONG | tID ;

dimlist: dimlist ',' tID tAS type
	| tID tAS type
	;

printstatement : tPRINT printllist
	|tPRINT '#' tInteger printllist
	|tPRINT '#' tInteger printllist ';'
	|tPRINT '#' tInteger printllist ','
	;

printllist : printllist ',' expression
	| expression
	;

expression : expression '+' expression
		| expression '-' expression
		| expression '*' expression
		| expression '/' expression
		| '(' expression ')'
		| varref '(' expression ')' // 这个也是函数调用
		| varref
		| tInteger //常量
;

varref:	varref '.' tID // 成员变量
	| varref tDREF  tID  // 指针解引用
	| tID
	;