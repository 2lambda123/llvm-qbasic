/*
    Parser of QBASIC to build Abstruct Syntax Tree
    * Copyright (C) 2009-2010 Thomas Larsen and Pedro Sá.
	* Copyright (C) 1995-2005 Marc-Oliver Ihm.
    * Copyright (C) 2012  microcai <microcai@fedoraproject.org>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 3 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
%skeleton "lalr1.cc"
%define namespace qb

%{

/* Include main header file. */
#include "qbc.h"
#include "parser.hpp"
#include <boost/make_shared.hpp>
#include <boost/concept_check.hpp>

extern	StatementAST * program;

extern int yylex(qb::parser::semantic_type * yylval_param );

//extern int yylex_destroy(void);
//extern void yyerror (char *msg);
extern int yylineno;

#define debug printf

/* Global variables. */
std::string current_function;  /* name of currently parsed function */
int in_loop = 0;                /* in loop? */

/* Local variables. */
int continue_corrections = 0;   /* continue corrections */
int unclosed_dos = 0;           /* unclosed "if" count */
int unclosed_fors = 0;          /* unclosed "for" count */
int unclosed_ifs = 0;           /* unclosed "if" count */
int unclosed_repeats = 0;       /* unclosed "repeat" count */
int unclosed_subs = 0;          /* unclosed subroutine count */
int unclosed_switches = 0;      /* unclosed "switch" count */
int unclosed_whiles = 0;        /* unclosed "while" count */
bool useDefautSubMain = false;	/* shall we treat the while file as an sub main ? */

void qb::parser::error(const parser::location_type& loc, const std::string& msg)
{
	std::cerr << msg << " at line " << yylineno << std::endl ;
	exit(1);
}

%}

%union {
	char *				string;         /* quoted string */
	std::string *		id;         /* general symbol */
	double 				number;        /* double number */
	long				integer;			/* long number */

	ReferenceAST*		varref;
	
	ExprTypeAST *  		exprtype;
	NumberExprAST* number_expression;
    VariableRefExprAST*varable_ref;	
	
	StatementAST* statement;
	StatementAST* statement_list;
	AssigmentAST*variable_assignment;
	IFStmtAST * if_clause;
	
	WhileLoopAST* while_loop;
	
	VariableDimAST*dim_list;
	FunctionDimAST	 *function_definition;

	PrintIntroAST *print_intro;
	PrintListAST * print_list;
	std::string 	*cppstring;
}

%token  tEOPROG

// 操作符
%left tOR
%left tAND
%right tNOT
%left tNEQ
%left tGEQ
%left tLEQ
%left tLTN
%left tGTN
%left tEQU
%left '-' '+'
%left '*' '/' tMOD
%right UMINUS UPLUS
%left tPOW

%nonassoc tDREF
%nonassoc '.'

//关键字

%token tAS
%token tSUB
%token tSUBEND

%token tFUNCTION
%token tFUNCTIONEND
%token tDIM tLET tPRINT

%token tNEWLINE


// 内置数据类型
%token tLONG 

// 数据 , 标识符, 变量名, 函数名, 等等
%token <id>		tID
%token <integer> tInteger
%token <string>	tSTRING
%token <number> tNUMBER

%type <varref> varref

%%

program: lines tEOPROG {
			if(useDefautSubMain){
				debug("program ended\n");
				//program = new DefaultMainFunctionAST( $1 );
			}else{
				//program = $1;
				debug("module ended\n");
			}
			YYACCEPT;
		}
		| lines statements tEOPROG {

			debug("!!!no new line at the end of file!!!\n");
			if(useDefautSubMain){
				debug("program ended\n");
				//program = new DefaultMainFunctionAST( $1 );
			}else{
				//program = $1;
				debug("module ended\n");
			}
			YYACCEPT;
			
		}
		;

lines : lines line
	| line ;

line : statements tNEWLINE
	| expression tNEWLINE
	| tNEWLINE
	;

statements : statements ':' statement
		| statement
		| subdefine
		| expression ':'
		| expression tNEWLINE
		;

statement : printstatement
		| tDIM dimlist
		| tFUNCTION tID '(' dimlist ')' tAS type
		| tFUNCTION tID '(' dimlist ')'
		| tFUNCTIONEND
		| assigment
		;

subdefine: tSUB  tID '(' ')'
				lines
			tSUBEND {
				debug("got a sub define\n");
			}
		| tSUB  tID '(' dimlist ')'
				lines
			tSUBEND {
				debug("got a sub define 2\n");
			}
		  ;

assigment: varref tEQU expression
		| tLET varref tEQU expression
		;

type: tLONG | tID ;

dimlist: dimlist ',' tID tAS type
	| tID tAS type
	;

printstatement :
	tPRINT  printinto  printllist  { debug("got print1 done\n") ;}
	|tPRINT printinto  printllist ',' { debug("got print2 done\n") ;}
	|tPRINT  printinto  printllist ';' { debug("got print3 done\n") ;}

	;

printinto: '#' tInteger ','  { debug("print has got itger\n") ;}
	| /*empty*/	{  debug("empty printinto\n");	}
	;
	
printllist: printllist ',' expression
	| expression
	;

expression:
		| varref '('  ')' { debug("functioncall with no arg\n");} // 这个也是函数调用
		| varref  '(' expression_list ')' // 这个可能是函数调用, 也许是数组哦 :)
		| varref  
		 '(' expression ')'
		| expression '+' expression
		| expression '-' expression
		| expression '*' expression
		| expression '/' expression
		| tInteger  {
			//常量
			
		}
		| tNUMBER //浮点数
		;

expression_list : expression_list ',' expression
			| expression
			;

varref:	varref '.' tID { debug("ref menber %s . %s \n", $1->ID.c_str()  , $3 );  }// 成员变量
	| varref tDREF  tID  // 指针解引用
	| tID {
		// 变量的引用? 反正是一个标识符的引用,
		// 所以我构建一个标识符引用语句. 这个会被用来构建函数调用和数组语句
		$$ = new ReferenceAST( $1 );
		debug("idref\n");
	}
	;