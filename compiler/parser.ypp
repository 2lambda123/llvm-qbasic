/*
    Parser of QBASIC to build Abstruct Syntax Tree
    * Copyright (C) 2009-2010 Thomas Larsen and Pedro Sá.
	* Copyright (C) 1995-2005 Marc-Oliver Ihm.
    * Copyright (C) 2012  microcai <microcai@fedoraproject.org>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 3 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
%skeleton "lalr1.cc"
%define namespace qb

%{

/* Include main header file. */
#include "qbc.h"
#include "parser.hpp"
#include <boost/make_shared.hpp>

extern	StatementAST * program;


extern int yylex(qb::parser::semantic_type * yylval_param );

//extern int yylex_destroy(void);
//extern void yyerror (char *msg);
extern int yylineno;

#define debug printf

/* Types of functions. */
enum {
   ftNONE, ftNUMBER, ftSTRING
};


/* Global variables. */
std::string current_function;  /* name of currently parsed function */
int in_loop = 0;                /* in loop? */

/* Local variables. */
int continue_corrections = 0;   /* continue corrections */
int unclosed_dos = 0;           /* unclosed "if" count */
int unclosed_fors = 0;          /* unclosed "for" count */
int unclosed_ifs = 0;           /* unclosed "if" count */
int unclosed_repeats = 0;       /* unclosed "repeat" count */
int unclosed_subs = 0;          /* unclosed subroutine count */
int unclosed_switches = 0;      /* unclosed "switch" count */
int unclosed_whiles = 0;        /* unclosed "while" count */
bool until_eol = false;          /* read to end of line? */
bool useDefautSubMain = false;	/* shall we treat the while file as an sub main ? */

/* Sanity check routine. */
void not_inside_loop_or_conditional (char *what) {
   /* Display an error if necessary. */
   if ((unclosed_dos || unclosed_fors || unclosed_repeats || unclosed_whiles) || (unclosed_ifs || unclosed_switches)) {
      if ((unclosed_dos || unclosed_fors || unclosed_repeats || unclosed_whiles) && (unclosed_ifs || unclosed_switches)) {
         debug ("cannot %s inside a loop, \"if\" statement, or \"switch\" construct", what);
      }
      else if (unclosed_dos || unclosed_fors || unclosed_repeats || unclosed_whiles) {
         debug ("cannot %s inside a loop", what);
      }
      else if (unclosed_ifs || unclosed_switches) {
         debug ("cannot %s inside an \"if\" statement or \"switch\" construct", what);
      }
   }

   /* Return. */
   return;
}

void qb::parser::error(const parser::location_type& loc, const std::string& msg)
{
	std::cerr << msg << " at line " << yylineno << std::endl ;
	exit(1);
}


%}

%union {
	char *string;         /* quoted string */
	char *symbol;         /* general symbol */
	double number;        /* double number */
	int separator;        /* separator */
	ExprTypeAST *  exprtype;

	NumberExprAST* number_expression;
    VariableRefExprAST*varable_ref;	
	
	StatementAST* statement;
	StatementAST* statement_list;
	NumberAssigmentAST*number_assignment;
	IFStmtAST * if_clause;
	
	WhileLoopAST* while_loop;
	
	VariableDimAST*dim_list;
	FunctionDimAST	 *function_definition;

	PrintIntroAST *print_intro;
	PrintListAST * print_list;
	std::string 	*cppstring;
}

/*
 * Defination union needed for Generating AST
 */
%type <print_intro>			print_intro
%type <print_list>			print_list
%type <number_expression>	number_expression
%type <exprtype>			exprtype
%type <exprtype>			dim_as_type
%type <dim_list>			dim_list
%type <statement>			non_empty_statement
%type <statement>			statement
%type <statement_list>		statement_list
%type <statement_list>		list_of_statement_lists
%type <varable_ref>			numsym_s
%type <number_assignment>	number_assignment
%type <if_clause>			if_clause
%type <statement_list>		else_part

%type <while_loop>			while_loop

%type <function_definition> function_definition
// %type <function_declar>		function_declar

%type <symbol> number_function_or_array_any_params
%type <symbol> number_function_or_array_with_params
%type <symbol> numsym_a
%type <symbol> numsym_a_no_calls
%type <symbol> string_function_or_array_any_params
%type <symbol> string_function_or_array_with_params
%type <symbol> strsym_a
%type <symbol> strsym_a_no_calls
%type <symbol> strsym_s
%type <separator> separator_list

%token <number> tNUMBER
%token <string> tSTRING
%token <symbol> tNUMSYM tSTRSYM
%token <separator> tSEPARATOR

%token tCALL tBREAK tCONTINUE tSUB tENDSUB tRETURN tFUNCTION tENDFUNCTION

%token tAND tOR tNOT tEOR
%token tCOMPILE tEXECUTERETURNNUMBER tEXECUTERETURNSTRING
%token tCSUB tFROM
%token tGOTO tGOSUB tLABEL
%token tENABLE tDISABLE
%token tEOPROG tNEWFILE tEXIT
%token tEXPLICIT
%token tFOR tTO tNEXT tSTEP tWHILE tWEND tREPEAT tUNTIL tDO tLOOP
%token tIF tTHEN tELSE tELSEIF tENDIF
%token tAS
%token tLET tDIM tLOCAL tSTATIC tARDIM tARSIZE tINC tDEC
%token tNEQ tLEQ tGEQ tLTN tGTN tEQU tPOW
%token tPRINT tINPUT tLINE tUSING
%token tSTRUCT tENDSTRUCT
%token tSWITCH tSEND tCASE tDEFAULT
%token tDATA tENDDATA tREAD tRESTORE
%token tLONG

%token tABS tSIG tRAN tSQR tSQRT
%token tINT tFRAC tMIN tMAX
%token tLEFT tRIGHT tMID tUPPER tLOWER
%token tOPEN tCLOSE tEOF tSEEK tTELL tPEEK tPOKE
%token tSIN tASIN tCOS tACOS tTAN tATAN tEXP tLOG
%token tSTR tCHR tVAL tASC tLEN
%token tSYSTEM tARG tENV
%token tTIME tDATE
%token tTOKEN tTOKENALT tSPLIT tSPLITALT tGLOB
%token tTRIM tLTRIM tRTRIM tINSTR tRINSTR

%left tOR
%left tAND
%right tNOT
%left tNEQ
%left tGEQ
%left tLEQ
%left tLTN
%left tGTN
%left tEQU
%left '-' '+'
%left '*' '/' tMOD
%right UMINUS UPLUS
%left tPOW
%nonassoc '.'

%%

program: list_of_statement_lists tEOPROG
        /* Note that it is absolutely essential that the "exit"
         * command be added here, because extra commands might be
         * added later and sequential execution of them could prove
         * disastrous. */
        {
			if(useDefautSubMain){
				debug("program ended\n");
				program = new DefaultMainFunctionAST( $1 );
			}else{
				program = $1;
				debug("module ended\n");
			}
			
			/*add_command (cEOPROG, NULL);*/
			// yylex_destroy ();
			YYACCEPT;
		}
   ;

list_of_statement_lists: statement_list   ;

statement_list: statement { $$ = new StatementAST(); $$->addchild(StatementASTPtr($1));
			debug("statement_list %p app %p  now\n", $$ , $1);
}
   | statement_list tSEPARATOR { yylineno += $2; } statement {
			$$ = $1;
			debug("statement_list %p app %p  now\n", $$ , $4);
			$$->addchild( StatementASTPtr($4) );
	}
   ;

statement: /* empty */ { $$ = new EmptyStmtAST(); debug("got empty statement %p\n" , $$); }
   | non_empty_statement { $$ = $1;
	   debug( "got non_empty_statement %p\n", $$ );
}
   ;

non_empty_statement: number_assignment
   | string_assignment
   | tLET number_assignment
   | tLET string_assignment
   | if_clause
   | short_if
   | do_loop
   | for_loop
   | repeat_loop
   | while_loop
   | switch_number_or_string
   | tBREAK {
	   /*add_command (cBREAK, NULL); */
	   if (! (in_loop)) { debug ("cannot \"break\" outside of loop"); }
   }
   | tCONTINUE {
	   /*add_command (cCONTINUE, NULL)->tag = continue_corrections;*/
	   if (! (in_loop)) {
		   debug ("cannot \"continue\" outside of loop");
	   }
	} 
   | function_definition { $$ = $1 ; debug ("got function %p as statement\n", $$) ;  }
   | structure_definition
   | number_function_or_array_any_params { }
   | string_function_or_array_any_params { }
   | tPRINT print_intro print_list {
	   // 构造打印语句
	   debug("got PRINT now\n");
	   //TODO 最后一个是 \new line
		$3->additem(boost::make_shared<EmptyExprAST>());
	   
		$$ = new PrintStmtAST(PrintIntroASTPtr($2),PrintListASTPtr($3));

		if(current_function.empty())
			useDefautSubMain = true;

   }
   | tPRINT print_intro print_list ';' {
	   // 构造打印语句
	   debug("got PRINT now with ; \n");	   
	   $$ = new PrintStmtAST(PrintIntroASTPtr($2),PrintListASTPtr($3));
	   if(current_function.empty())
			useDefautSubMain = true;
   }   
   | tPRINT print_intro print_list ',' {
	   // 构造打印语句
	   debug("got PRINT now with ; \n");
	   $$ = new PrintStmtAST(PrintIntroASTPtr($2),PrintListASTPtr($3));
	   if(current_function.empty())
			useDefautSubMain = true;
   }
   | tINPUT { until_eol = false; } input_body {}
   | tLINE tINPUT { until_eol = true; } input_body {}
   | tRETURN {
	   
             }
   | tRETURN number_expression {

	   
   }

   | tRETURN string_expression { }
   | tDIM dim_list {
	   debug("got syntax of \"dim local var\" now\n");

	   $$ = $2;	   
	}
   | tSYSTEM '(' string_expression ')' { }
   | tEXIT {}
   | tEXIT number_expression {}
   | tOPEN hashed_number ',' string_expression {}
   | tOPEN hashed_number ',' string_expression ',' string_expression {}
   | tCLOSE hashed_number {}
   | tSEEK hashed_number ',' number_expression {}
   | tSEEK hashed_number ',' number_expression ',' string_expression {}
   | tDEC dec_list
   | tINC inc_list
   | tGOTO numsym_s {

   }
   | tGOSUB numsym_s {  }
   | tLABEL numsym_s {
		debug("got label!\n");
   }
   | tPOKE hashed_number ',' number_expression {  }
   | tCOMPILE string_expression {  }
   | tEXECUTERETURNNUMBER '(' {  } call_list ')' {
	 //  create_execute (ftNUMBER); add_command (cPOP, NULL); add_command (cPOP, NULL);
   }
   | tEXECUTERETURNSTRING '(' { } call_list ')' {  }
   | tDATA numsym_s { /*data = create_data (dotify ($2));*/ } separator_list data_list tENDDATA
   | tREAD read_list
   | tRESTORE restore_list
   ;

data_list: data_row
   | data_list data_row
   ;

data_row: data_row_items separator_list
   ;

data_row_items: data_item
   | data_row_items ',' data_item
   ;

data_item: tNUMBER   { /*data_add (data, 'n')->number_value = $1; */}
   | '-' tNUMBER     { /*data_add (data, 'n')->number_value = -$2;*/ }
   | tSTRING         { /*data_add (data, 's')->string_value = $1; */}
   ;

read_list: read_item
   | read_list ',' read_item
   ;

read_item: numsym_s tFROM numsym_s { /*add_command (cDATAREAD, dotify ($3))->tag = 'n'; add_command (cPOPNUMSYM, dotify ($1)); */}
   | strsym_s tFROM numsym_s { /*add_command (cDATAREAD, dotify ($3))->tag = 's'; add_command (cPOPSTRSYM, dotify ($1)); */}
   | numsym_a tFROM numsym_s { /*add_command (cDATAREAD, dotify ($3))->tag = 'n'; create_doarray (dotify ($1), ASSIGNNUMBERARRAY);*/ }
   | strsym_a tFROM numsym_s { /*add_command (cDATAREAD, dotify ($3))->tag = 's'; create_doarray (dotify ($1), ASSIGNSTRINGARRAY);*/ }
   ;

restore_list: numsym_s { /*add_command (cDATARESTORE, dotify ($1)); */}
   | restore_list ',' numsym_s {/* add_command (cDATARESTORE, dotify ($3)); */}
   ;

number_assignment: numsym_s tEQU number_expression {
		// 变量赋值
		debug("变量赋值\n");
		$$ = new NumberAssigmentAST(VariableRefExprASTPtr($1), NumberExprASTPtr($3));
		if(current_function.empty())
			useDefautSubMain = true;
	}
   | number_function_or_array_with_params tEQU number_expression {/*create_doarray($1,ASSIGNNUMBERARRAY);*/}
   ;

string_assignment: strsym_s tEQU string_expression {/*add_command(cPOPSTRSYM,dotify($1));*/}
   | tMID '(' string_scalar_or_array ',' number_expression ',' number_expression ')' tEQU string_expression {/*create_changestring(fMID);*/}
   | tMID '(' string_scalar_or_array ',' number_expression ')' tEQU string_expression {/*create_changestring(fMID2);*/}
   | tLEFT '(' string_scalar_or_array ',' number_expression ')' tEQU string_expression {/*create_changestring(fLEFT);*/}
   | tRIGHT '(' string_scalar_or_array ',' number_expression ')' tEQU string_expression {/*create_changestring(fRIGHT);*/}
   | string_function_or_array_with_params tEQU string_expression {
	   //create_doarray($1,ASSIGNSTRINGARRAY);
   }
   ;

string_scalar_or_array: strsym_s {/*add_command(cPUSHSTRPTR,dotify($1));*/}
   | strsym_a {/*create_doarray(dotify($1),GETSTRINGPOINTER);*/}
   ;

string_expression: strsym_s {		/*add_command(cPUSHSTRSYM,dotify($1));*/	}
   | string_function
   | string_function_or_array_any_params {/*add_command(cSTRING_FUNCTION_OR_ARRAY,$1);*/}
   | tSTRING {/*create_pushstr($1);*/}
   | string_expression '+' string_expression {/*add_command(cCONCAT,NULL);*/}
   | '(' string_expression ')'
   ;

string_function: tLEFT '(' string_expression ',' number_expression ')' {/*create_function(fLEFT);*/}
   | tRIGHT '(' string_expression ',' number_expression ')' {/*create_function(fRIGHT);*/}
   | tMID '(' string_expression ',' number_expression ',' number_expression ')' {/*create_function(fMID);*/}
   | tMID '(' string_expression ',' number_expression ')' {/*create_function(fMID2);*/}
   | tSTR '(' number_expression ')' {/*create_function(fSTR);*/}
   | tSTR '(' number_expression ',' string_expression ')' {/*create_function(fSTR2);*/}
   | tSTR '(' number_expression ',' string_expression ',' string_expression ')' {/*create_function(fSTR3);*/}
   | tCHR '(' number_expression ')' {/*create_function(fCHR);*/}
   | tUPPER '(' string_expression ')' {/*create_function(fUPPER);*/}
   | tLOWER '(' string_expression ')' {/*create_function(fLOWER);*/}
   | tLTRIM '(' string_expression ')' {/*create_function(fLTRIM);*/}
   | tRTRIM '(' string_expression ')' {/*create_function(fRTRIM);*/}
   | tTRIM '(' string_expression ')' {/*create_function(fTRIM);*/}
   | tTOKENALT '(' string_scalar_or_array ',' string_expression ')' {/*add_command(cTOKENALT2,NULL);*/}
   | tTOKENALT '(' string_scalar_or_array ')' {/*add_command(cTOKENALT,NULL);*/}
   | tSPLITALT '(' string_scalar_or_array ',' string_expression ')' {/*add_command(cSPLITALT2,NULL);*/}
   | tSPLITALT '(' string_scalar_or_array ')' {/*add_command(cSPLITALT,NULL);*/}
   | tDATE {/*create_function(fDATE);*/}
   | tTIME {/*create_function(fTIME);*/}
   | tARG '(' number_expression ')' { /*create_function (fARG); */}
   | tENV '(' string_expression ')' { /*create_function (fENV); */}
   | tEXECUTERETURNSTRING '(' { /*add_command (cPUSHFREE, NULL);*/ } call_list ')' { /*create_execute (ftSTRING); add_command (cSWAP, NULL); add_command (cPOP, NULL); */}
   ;

number_expression: number_expression tOR {/*add_command(cORSHORT,NULL);pushlabel();*/} number_expression {/*poplabel();create_boole('|');*/}
   | number_expression tAND {/*add_command(cANDSHORT,NULL);pushlabel();*/} number_expression {/*poplabel();create_boole('&');*/}
   | tNOT number_expression {/*create_boole('!');*/}
   | number_expression tEQU number_expression {/*create_numrelop('=');*/}
   | number_expression tNEQ number_expression {/*create_numrelop('!');*/}
   | number_expression tLTN number_expression {/*create_numrelop('<');*/}
   | number_expression tLEQ number_expression {/*create_numrelop('{');*/}
   | number_expression tGTN number_expression {/*create_numrelop('>');*/}
   | number_expression tGEQ number_expression {/*create_numrelop('}');*/}
   | tEOF '(' hashed_number ')' {/*add_command(cTESTEOF,NULL);*/}
   | tGLOB '(' string_expression ',' string_expression ')' {/*add_command(cGLOB,NULL);*/}
   | tARDIM '(' number_arrayref ')' {/*add_command(cARDIM,"");*/}
   | tARDIM '(' string_arrayref ')' {/*add_command(cARDIM,"");*/}
   | tARSIZE '(' number_arrayref ',' number_expression ')' {/*add_command(cARSIZE,"");*/}
   | tARSIZE '(' string_arrayref ',' number_expression ')' {/*add_command(cARSIZE,"");*/}
   | number_function_or_array_any_params {/*add_command(cNUMBER_FUNCTION_OR_ARRAY,$1);*/}
   | string_expression tEQU string_expression {/*create_strrelop('=');*/}
   | string_expression tNEQ string_expression {/*create_strrelop('!');*/}
   | string_expression tLTN string_expression {/*create_strrelop('<');*/}
   | string_expression tLEQ string_expression {/*create_strrelop('{');*/}
   | string_expression tGTN string_expression {/*create_strrelop('>');*/}
   | string_expression tGEQ string_expression {/*create_strrelop('}');*/}
   | number_function
   | number_expression tMOD number_expression {/*create_numbin('%');*/}
   | number_expression tPOW number_expression {/*create_numbin('^');*/}
   | '+' number_expression %prec UPLUS {
	   $$ = $2 ;
   }
   | '-' number_expression %prec UMINUS {
	   /*add_command(cNEGATE,NULL);*/
	   ConstNumberExprAST * zero = new ConstNumberExprAST(0);
	   $$ = new NumberCalcExprAST( NumberExprASTPtr(zero) ,OPERATOR_SUB,NumberExprASTPtr($2));
   }
   | number_expression '*' number_expression {
	   $$ = new NumberCalcExprAST( NumberExprASTPtr($1),OPERATOR_MUL,NumberExprASTPtr($3));
   }
   | number_expression '/' number_expression {
	   $$ = new NumberCalcExprAST( NumberExprASTPtr($1),OPERATOR_DIV,NumberExprASTPtr($3));
   }
   | number_expression '-' number_expression {
	   // 减法计算
	   $$ = new NumberCalcExprAST( NumberExprASTPtr($1),OPERATOR_SUB,NumberExprASTPtr($3));
   }
   | number_expression '+' number_expression {
	   // 加法计算.
	   $$ = new NumberCalcExprAST( NumberExprASTPtr($1),OPERATOR_ADD,NumberExprASTPtr($3));
   }
   | '(' number_expression ')' { $$ = $2 ;}
   | numsym_s {
	   debug("got numsym_s\n");	   
	   $$ =new NumberExprAST( VariableExprASTPtr($1) );
	}
   | tNUMBER {
	   $$ = new ConstNumberExprAST($1);
   }
   ;

number_arrayref: numsym_a_no_calls {/*create_pusharrayref(dotify($1),stNUMBERARRAYREF);*/}
   ;

string_arrayref: strsym_a_no_calls {/*create_pusharrayref(dotify($1),stSTRINGARRAYREF);*/}
   ;

number_function: tSIN '(' number_expression ')' {/*create_function(fSIN);*/}
   | tASIN '(' number_expression ')' {/*create_function(fASIN);*/}
   | tCOS '(' number_expression ')' {/*create_function(fCOS);*/}
   | tACOS '(' number_expression ')' {/*create_function(fACOS)*/;}
   | tTAN '(' number_expression ')' {/*create_function(fTAN);*/}
   | tATAN '(' number_expression ')' {/*create_function(fATAN);*/}
   | tATAN '(' number_expression ',' number_expression  ')' {/*create_function(fATAN2);*/}
   | tEXP '(' number_expression ')' {/*create_function(fEXP);*/}
   | tLOG '(' number_expression ')' {/*create_function(fLOG);*/}
   | tLOG '(' number_expression ',' number_expression ')' {/*create_function(fLOG2);*/}
   | tINT '(' number_expression ')' {/*create_function(fINT);*/}
   | tSQR '(' number_expression ')' {/*create_function(fSQR);*/}
   | tSQRT '(' number_expression ')' {/*create_function(fSQRT);*/}
   | tFRAC '(' number_expression ')' {/*create_function(fFRAC);*/}
   | tABS '(' number_expression ')' {/*create_function(fABS);*/}
   | tSIG '(' number_expression ')' {/*create_function(fSIG);*/}
   | tRAN '(' number_expression ')' {/*create_function(fRAN);*/}
   | tRAN '(' ')' {/*create_function(fRAN2);*/}
   | tMIN '(' number_expression ',' number_expression ')' {/*create_function(fMIN);*/}
   | tMAX '(' number_expression ',' number_expression ')' {/*create_function(fMAX);*/}
   | tLEN '(' string_expression ')' {/*create_function(fLEN);*/}
   | tVAL '(' string_expression ')' {/*create_function(fVAL);*/}
   | tASC '(' string_expression ')' {/*create_function(fASC);*/}
   | tINSTR '(' string_expression ',' string_expression ')' {/*create_function(fINSTR);*/}
   | tINSTR '(' string_expression ',' string_expression ',' number_expression ')' {/*create_function(fINSTR2);*/}
   | tRINSTR '(' string_expression ',' string_expression ')' {/*create_function(fRINSTR);*/}
   | tRINSTR '(' string_expression ',' string_expression  ',' number_expression ')' {/*create_function(fRINSTR2);*/}
   | tSYSTEM '(' string_expression ')' {/*create_function(fSYSTEM);*/}
   | tAND '(' number_expression ',' number_expression ')' {/*create_function(fAND);*/}
   | tOR '(' number_expression ',' number_expression ')' {/*create_function(fOR);*/}
   | tEOR '(' number_expression ',' number_expression ')' {/*create_function(fEOR);*/}
   | tTOKEN '(' string_expression ',' string_arrayref ',' string_expression ')' {/*add_command(cTOKEN2,NULL);*/}
   | tTOKEN '(' string_expression ',' string_arrayref ')' {/*add_command(cTOKEN,NULL);*/}
   | tSPLIT '(' string_expression ',' string_arrayref ',' string_expression ')' {/*add_command(cSPLIT2,NULL);*/}
   | tSPLIT '(' string_expression ',' string_arrayref ')' {/*add_command(cSPLIT,NULL);*/}
   | tOPEN '(' string_expression ')' {/*create_myopen (OPEN_FUNCTION);*/}
   | tOPEN '(' string_expression ',' string_expression ')' {/*create_myopen (OPEN_FUNCTION + OPEN_HAS_MODE);*/}
   | tOPEN '(' hashed_number ',' string_expression ')' {/*create_myopen (OPEN_FUNCTION + OPEN_HAS_STREAM);*/}
   | tOPEN '(' hashed_number ',' string_expression ',' string_expression ')' {/*create_myopen (OPEN_FUNCTION + OPEN_HAS_STREAM + OPEN_HAS_MODE);*/}
   | tTELL '(' hashed_number ')' { /*create_function (fTELL); */}
   | tPEEK '(' hashed_number ')' { /*create_function (fPEEKFILE);*/ }
   | tEXECUTERETURNNUMBER '(' { /*add_command (cPUSHFREE, NULL);*/ } call_list ')' { /*create_execute (ftNUMBER); add_command (cSWAP, NULL); add_command (cPOP, NULL);*/ }
   ;

hashed_number: '#' number_expression
  | number_expression
  ;

exprtype: tLONG {
		$$ = new NumberTypeAST();
	}
	| tINT {
		//TODO int should be 32bit not 64bit
		$$ = new NumberTypeAST();
	}
	;
  
dim_as_type:	/* empty , default to INTGER*/
		| tAS exprtype {
			debug("as  %s\n",$2->name.c_str());
			// long varable
			// 构造类型
			$$ = $2;
		}
		;

dim_list: tNUMSYM dim_as_type {
		/*变量定义*/
		// 在 AST 中分配一个变量名称列表.
		std::string name;
		name = $1;
		$$ = new VariableDimAST( name , ExprTypeASTPtr($2));		
	}
   | strsym_a dim_as_type {/*create_dim(dotify($1),'S');*/}
   | dim_list ',' tNUMSYM dim_as_type {
	  // 	std::string name;
	//	name = $3;
	//	$$ = new VariableDimAST( name , ExprTypeASTPtr($2));
   }
   | dim_list ',' strsym_a dim_as_type {/*create_dim(dotify($3),'S');*/}
   ;

number_function_or_array_any_params: numsym_a {/*$$ = dotify ($1);*/}
   | numsym_a_no_calls { /*add_command (cPUSHFREE, NULL); $$ = dotify ($1); */}
   ;

number_function_or_array_with_params: numsym_a {/*$$ = dotify ($1);*/}
   ;

string_function_or_array_any_params: strsym_a {/*$$ = dotify ($1);*/}
   | strsym_a_no_calls {/* add_command (cPUSHFREE, NULL); $$ = dotify ($1); */}
   ;

string_function_or_array_with_params: strsym_a {/*$$ = dotify ($1);*/}
   ;

call_list: call_item { /*if (cli != NULL) { cli->items++; }*/ }
   | call_list ',' call_item { /*if (cli != NULL) { cli->items++; }*/ }
   ;

call_item: string_expression
   | number_expression
   ;

begin_sub:	tSUB { unclosed_subs++; }
	| tFUNCTION { unclosed_subs++; }
	;

function_definition:
	begin_sub { not_inside_loop_or_conditional ("define a function");
	}  tNUMSYM {
		$<cppstring>$ = new std::string($3);
		debug("====begin function %s====\n",$3);
		current_function = $3;
	}  '(' param_list ')' dim_as_type
	statement_list
	endsub {
		$$ = new FunctionDimAST(current_function, ExprTypeASTPtr($8) );
		$$->body = StatementASTPtr($9);
		debug("====end function %s==== %p , body = %p\n",($<cppstring>4)->c_str(),$$ , $9);
		delete $<cppstring>4;
		current_function.clear();
	}
	;

endsub: tEOPROG {
		if (unclosed_subs)
		{
			debug ("%d subroutine%s not closed", unclosed_subs, (unclosed_subs > 1) ? "s" : "");
		}
	}
   | tENDSUB {unclosed_subs--;}
   | tENDFUNCTION {unclosed_subs--;}
   ;

local_list: local_item
   | local_list ',' local_item
   ;

local_item: numsym_s {/* create_makelocal (dotify ($1), syNUMBER);*/ }
   | strsym_s {/* create_makelocal (dotify ($1), sySTRING); */}
   | numsym_a { /*create_makelocal (dotify ($1), syARRAY); create_dim (dotify ($1), 'n'); */}
   | strsym_a { /*create_makelocal (dotify ($1), syARRAY); create_dim (dotify ($1), 's'); */}
   ;

static_list: static_item
   | static_list ',' static_item
   ;

static_item: numsym_s { /*create_makestatic (dotify ($1), syNUMBER);*/ }
   | strsym_s { /*create_makestatic (dotify ($1), sySTRING);*/ }
   | numsym_a { /*create_makestatic (dotify ($1), syARRAY); create_dim (dotify ($1), 'N'); */}
   | strsym_a {/* create_makestatic (dotify ($1), syARRAY); create_dim (dotify ($1), 'S'); */}
   ;

param_list: /* empty */
   | param_item
   | param_list ',' param_item
   ;

param_item: numsym_s {/*create_require(stNUMBER);create_makelocal(dotify ($1),syNUMBER);add_command(cPOPNUMSYM,dotify ($1));*/}
   | strsym_s {
	   
}
   | numsym_a_no_calls {
	   
}
   | strsym_a_no_calls {
	   
}
   ;

for_loop: tFOR { unclosed_fors++; } numsym_s tEQU
             {
				 
			}
     number_expression tTO number_expression
     step_part {
	 }
	  statement_list {/*
              swap();popgoto();poplabel();*/}
           next next_symbol {/*create_break_mark(0,-1);add_command(cBREAK_HERE,NULL);*/
		}
   ;

next: tEOPROG {
		if (unclosed_fors) {
			debug ("%d \"for\" loop%s not closed", unclosed_fors, (unclosed_fors > 1) ? "s" : "");
		}
	}
   | tNEXT {unclosed_fors--;}
   ;

next_symbol: /* empty */ {/* pop (stSTRING);*/ }
   | numsym_s {  }
   ;

step_part: {/*create_pushnum(1);*/} /* can be omitted */
   | tSTEP number_expression
   ;

switch_number_or_string: tSWITCH { unclosed_switches ++; } {
	}
	number_or_string separator_list case_list default tSEND { unclosed_switches --; } {continue_corrections --;
					 
				}
   ;

separator_list: tSEPARATOR { yylineno += $1; }
   | separator_list tSEPARATOR { yylineno += $2; }
   ;

number_or_string: number_expression
   | string_expression
   ;

case_list: /* empty */
   | case_list tCASE {
	   
} number_or_string
       {
		   
	}
   ;

default: /* empty */
   | tDEFAULT tSEPARATOR { yylineno+=$2; } {

	   
} statement_list
   ;

do_loop: tDO { unclosed_dos++; } {/*add_command(cCONTINUE_HERE,NULL);create_break_mark(0,1);pushgoto();*/}
         statement_list
             loop
   ;

loop: tEOPROG {if (unclosed_dos) { debug ("%d \"do\" loop%s not closed", unclosed_dos, (unclosed_dos > 1) ? "s" : ""); } }
   | tLOOP {unclosed_dos--;} {/*popgoto();create_break_mark(0,-1);add_command(cBREAK_HERE,NULL);*/}
   ;

while_loop: tWHILE { unclosed_whiles++; debug("while ...\n"); } number_expression
		statement_list
	wend {
		//TODO 添加 while 循环
		$$ = new WhileLoopAST( NumberExprASTPtr($3) , StatementASTPtr($4) );
		$4->parent = $$;
	};

wend: tEOPROG {if (unclosed_whiles) { debug ("%d \"while\" loop%s not closed", unclosed_whiles, (unclosed_whiles > 1) ? "s" : ""); } }
   | tWEND {unclosed_whiles--;} { }
   ;

repeat_loop: tREPEAT { unclosed_repeats++; } {/*add_command(cCONTINUE_HERE,NULL);create_break_mark(0,1);pushgoto();*/}
          statement_list
        until
   ;

until: tEOPROG {if (unclosed_repeats) { debug ("%d \"repeat\" loop%s not closed", unclosed_repeats, (unclosed_repeats > 1) ? "s" : ""); } }
   | tUNTIL number_expression
          {unclosed_repeats--;} {/*add_command(cDECIDE,NULL);popgoto();create_break_mark(0,-1);add_command(cBREAK_HERE,NULL);*/}
   ;

if_clause: if_part number_expression tTHEN 
				statement_list { debug("then part %p\n" , $4);}
			elseif_part {
				//TODO 
				debug("syntax not supported yet\n");
			}
            else_part {
				debug("else part %p\n" , $8);
			}
            endif {
				
				$$ = new IFStmtAST( NumberExprASTPtr( $2));
				$$->_then = StatementASTPtr($4);

				if($4)
					$4->parent = $$;
				
				$$->_else = StatementASTPtr($8);
				if($8)
					$8->parent = $$;

			}
            ;

short_if: if_part number_expression { /*add_command (cDECIDE, NULL); storelabel (); pushlabel ();*/ }
            non_empty_statement { unclosed_ifs--; } {/* swap (); matchgoto (); swap (); poplabel (); poplabel (); */}
   | if_part number_expression { /*add_command (cDECIDE, NULL); storelabel (); pushlabel ();*/ } separator_list
            non_empty_statement {/* unclosed_ifs--; } { swap (); matchgoto (); swap (); poplabel (); poplabel ();*/ }
   ;

endif: tEOPROG {if (unclosed_ifs) { debug ("%d \"if\" statement%s not closed", unclosed_ifs, (unclosed_ifs > 1) ? "s" : ""); } }
   | tENDIF {unclosed_ifs--;}
   ;

if_part: tIF { unclosed_ifs ++; }
   ;

else_part: /* can be omitted */ { $$ = 0; }
   | tELSE statement_list {	$$ = $2;}
   ;

elseif_part: /* can be omitted */
   | tELSEIF number_expression tTHEN
      {/*add_command(cDECIDE,NULL);pushlabel();*/}
     statement_list
   {/*swap();matchgoto();swap();poplabel();*/}
     elseif_part
   ;

input: numsym_s {/*create_myread ('n', until_eol); add_command (cPOPNUMSYM, dotify ($1)); */}
   | strsym_s {/*create_myread('s',until_eol);add_command(cPOPSTRSYM, dotify ($1));*/}
   | numsym_a {/*create_myread('n',until_eol);create_doarray(dotify ($1),ASSIGNNUMBERARRAY);*/}
   | strsym_a {/*create_myread('s',until_eol);create_doarray(dotify ($1),ASSIGNSTRINGARRAY);*/}
   ;

print_list:  /* empty */ {
		$$ = new PrintListAST();
	}
   | number_expression {
		debug("got first print argument as number\n");
		$$ = new PrintListAST();
		$$->additem(ExprASTPtr($1));
   }
   | number_expression tUSING string_expression
        { debug("ERROR: print syntax not supprted yet\n"); exit(1);}
   | string_expression
        { debug("ERROR: print syntax not supprted yet\n"); exit(1); }
   | print_list ',' number_expression
        { $$ = $1 ; $$->additem(ExprASTPtr($3)) ; }
   | print_list ',' number_expression tUSING string_expression
        {/* create_print ('b'); create_print ('u'); */}
   | print_list ',' string_expression
        { /*create_print ('b'); create_print ('s');*/ }
   ;

input_body: /* empty */ {/*create_pushnum(STDIO_STREAM);create_pps(cPUSHSTREAM,1);*/} prompt input
   | '#' numsym_s {/*add_command(cPUSHNUMSYM,dotify ($2));create_pps(cPUSHSTREAM,1);*/} input
   | '#' tNUMBER {/*create_pushnum ($2); create_pps(cPUSHSTREAM,1);*/} input
   | '#' '(' number_expression ')' {/*create_pps(cPUSHSTREAM,1);*/} input
   ;

prompt: string_expression
        {/* create_print ('s');*/ }
   ;

print_intro: /* empty */ {
		debug("empty print_intro\n");
		/*构造一个默认的 打印目标*/
		$$ = new PrintIntroAST(); 
	}
   | '#' numsym_s {  /* 构造一个使用常数表的打印目标*/ }
   | '#' tNUMBER {/*create_pushnum ($2); create_pps(cPUSHSTREAM,0);*/}
   | '#' '(' number_expression ')' {/*create_pps(cPUSHSTREAM,0);*/}
   ;

dec_list: numsym_s { /*add_command (cPUSHNUMSYM, dotify ($1)); create_pushnum (1); create_numbin ('-'); add_command (cPOPNUMSYM, dotify ($1));*/ }
   | dec_list ',' numsym_s {/* add_command (cPUSHNUMSYM, dotify ($3)); create_pushnum (1); create_numbin ('-'); add_command (cPOPNUMSYM, dotify ($3)); */}
   ;

inc_list: numsym_s { /*add_command (cPUSHNUMSYM, dotify ($1)); create_pushnum (1); create_numbin ('+'); add_command (cPOPNUMSYM, dotify ($1));*/ }
   | inc_list ',' numsym_s {
	/*   add_command (cPUSHNUMSYM, dotify ($3)); create_pushnum (1); create_numbin ('+'); add_command (cPOPNUMSYM, dotify ($3));*/ }
   ;

structure_definition: tSTRUCT new_cli numsym_s {
//                          if (cli->next == NULL) {
//                             cmd = add_command (cSTRUCT, dotify ($3));
//                          }
//                          else {
//                             cmd = add_command (cSTRUCT, $3);
//                          }
//                          cmd->args = cli->items;
//                          cmd->tag = syNUMBER;
                      }
                      separator_list structure_definition_parts tENDSTRUCT {
//                          add_command (cENDSTRUCT, NULL)->args = cli->items;
//                          next_cli = cli->next;
//                          xfree (cli);
//                          cli = next_cli;
                      }
   | tSTRUCT new_cli numsym_a {
//         if (cli->next == NULL) {
//            cmd = add_command (cSTRUCT, dotify ($3));
//         }
//         else {
//            cmd = add_command (cSTRUCT, $3);
//         }
//         cmd->args = cli->items;
//         cmd->tag = syNUMBER;
     }
     separator_list structure_definition_parts tENDSTRUCT {
//         add_command (cENDSTRUCT, NULL)->args = cli->items;
//         next_cli = cli->next;
//         xfree (cli);
//         cli = next_cli;
     }
   ;

structure_definition_parts: structure_definition_variable separator_list
   | structure_definition_parts structure_definition_variable separator_list
   ;

structure_definition_variable: structure_definition
   | new_cli numsym_s {
//         cmd = add_command (cSTRUCTVAR, $2);
//         cmd->args = cli->items;
//         cmd->tag = syNUMBER;
//         next_cli = cli->next;
//         xfree (cli);
//         cli = next_cli;
     }
   | new_cli strsym_s {
//         cmd = add_command (cSTRUCTVAR, $2);
//         cmd->args = cli->items;
//         cmd->tag = sySTRING;
//         next_cli = cli->next;
//         xfree (cli);
//         cli = next_cli;
     }
   | new_cli numsym_a {
//         cmd = add_command (cSTRUCTVAR, $2);
//         cmd->args = cli->items;
//         cmd->tag = syNUMBER;
//         next_cli = cli->next;
//         xfree (cli);
//         cli = next_cli;
     }
   | new_cli strsym_a {
//         cmd = add_command (cSTRUCTVAR, $2);
//         cmd->args = cli->items;
//         cmd->tag = sySTRING;
//         next_cli = cli->next;
//         xfree (cli);
//         cli = next_cli;
     }
   ;

new_cli: {
//             old_cli = cli;
//             cli = xmalloc (sizeof (struct cli));
//             cli->items = 0;
//             cli->next = old_cli;
         }
   ;

numsym_s: tNUMSYM {
		debug("变量引用\n");
		$$ = new VariableRefExprAST( $1 );
	}
   | numsym_s '.' tNUMSYM { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1); */}
   ;

numsym_a: tNUMSYM '(' {
		//该决定是否为函数还是数组了
	}
	| numsym_a '.' tNUMSYM '(' call_list ')' { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1);*/ }
   | numsym_a '.' tNUMSYM { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1);*/ }
   | numsym_s '.' tNUMSYM '(' { /*add_command (cPUSHFREE, NULL); } call_list ')' { $$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1);*/ }
   ;

numsym_a_no_calls: tNUMSYM '(' ')' {
// 	$$ = xmalloc ((strlen ($1) + 1) * sizeof (char)); strcpy ($$, $1);
 	}
   | numsym_a_no_calls '.' tNUMSYM '(' ')' { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1);*/ }
   | numsym_a_no_calls '.' tNUMSYM { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1); */}
   | numsym_s '.' tNUMSYM '(' ')' { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1);*/ }
   ;

strsym_s: tSTRSYM { /*$$ = xmalloc ((strlen ($1) + 1) * sizeof (char)); strcpy ($$, $1);*/ }
   | numsym_s '.' tSTRSYM { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1);*/ }
   ;

strsym_a: tSTRSYM '(' { /*add_command (cPUSHFREE, NULL); } call_list ')' { $$ = xmalloc ((strlen ($1) + 1) * sizeof (char)); strcpy ($$, $1);*/ }
   | numsym_a '.' tSTRSYM '(' call_list ')' { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1);*/ }
   | numsym_a '.' tSTRSYM { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1);*/ }
   | numsym_s '.' tSTRSYM '(' {/* add_command (cPUSHFREE, NULL);*/ } call_list ')' { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1); */}
   ;

strsym_a_no_calls: tSTRSYM '(' ')' { /*$$ = xmalloc ((strlen ($1) + 1) * sizeof (char)); strcpy ($$, $1);*/ }
   | numsym_a_no_calls '.' tSTRSYM '(' ')' { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1);*/ }
   | numsym_a_no_calls '.' tSTRSYM { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1);*/ }
   | numsym_s '.' tSTRSYM '(' ')' { /*$$ = xmalloc (((strlen ($1) + 1 + strlen ($3)) + 1) * sizeof (char)); $$ [1 - 1] = '\0'; strcat ($$, $1); strcat ($$, "."); strcat ($$, $3); xfree ($1); */}
   ;
