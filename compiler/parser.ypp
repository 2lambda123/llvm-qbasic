/*
    Parser of QBASIC to build Abstruct Syntax Tree

    * Copyright (C) 2012  microcai <microcai@fedoraproject.org>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 3 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
%skeleton "lalr1.cc"
%define namespace qb

%{

/* Include main header file. */
#include "qbc.h"
#include "parser.hpp"
#include <boost/make_shared.hpp>
#include <boost/concept_check.hpp>

extern	StatementAST * program;

extern int yylex(qb::parser::semantic_type * yylval_param );

extern int yylineno;

#define debug printf

/* Global variables. */
bool useDefautSubMain = true;	/* shall we treat the while file as an sub main ? */

int in_loop = 0;                /* in loop? */

/* Local variables. */
int continue_corrections = 0;   /* continue corrections */
int unclosed_dos = 0;           /* unclosed "if" count */
int unclosed_fors = 0;          /* unclosed "for" count */
int unclosed_ifs = 0;           /* unclosed "if" count */
int unclosed_repeats = 0;       /* unclosed "repeat" count */
int unclosed_subs = 0;          /* unclosed subroutine count */
int unclosed_switches = 0;      /* unclosed "switch" count */
int unclosed_whiles = 0;        /* unclosed "while" count */

void qb::parser::error(const parser::location_type& loc, const std::string& msg)
{
	std::cerr << msg << " at line " << yylineno << std::endl ;
	exit(1);
}

%}

%union {
	char *				string;         /* quoted string */
	std::string *		id;         /* general symbol */
	double 				number;        /* double number */
	long				integer;			/* long number */

	ReferenceAST*		varref;
	ExprAST*			expression;
	ExprListAST*		expression_list;

	PrintIntroAST*		printinto;
	
	
	std::string *  		exprtype; // name of the type
	NumberExprAST* 		number_expression;
	CallExprAST*		call_function;

    PrintStmtAST*		printstatement;
	StatementAST*		statement;
	StatementsAST*		statement_list;
	AssigmentAST*		variable_assignment;
	CodeBlockAST*		codeblocks;
	IFStmtAST * if_clause;
	
	WhileLoopAST* while_loop;
	
	VariableDimAST*		dim_item;
	ArgumentDimsAST*	arg_list;
	FunctionDimAST	 *function_definition;

	PrintIntroAST *print_intro;
	std::string 	*cppstring;
}

%token  tEOPROG

// 操作符
%left tOR
%left tAND
%right tNOT
%left tNEQ
%left tGEQ
%left tLEQ
%left tLTN
%left tGTN
%left tEQU
%left '-' '+'
%left '*' '/' tMOD
%right UMINUS UPLUS
%left tPOW

%nonassoc tDREF
%nonassoc '.'

//关键字
%token tNEWLINE

%token tAS
%token tSUB
%token tSUBEND

%token tFUNCTION
%token tFUNCTIONEND
%token tRETURN
%token tDIM tLET tPRINT

%token tIF tTHEN tENDIF tELSE tELSEIF
%token tWHILE tENDWHILE

// 内置数据类型
%token tLONG tSTR 

// 数据 , 标识符, 变量名, 函数名, 等等
%token <id>		tID
%token <integer> tInteger
%token <string>	tSTRING
%token <number> tNUMBER

%type <expression>					expression
%type <expression_list>				expression_list
%type <printinto>					printinto
%type <printstatement>				printstatement
%type <codeblocks>					lines
%type <statement_list>				line
%type <statement_list>				statements
%type <statement>					statement
%type <dim_item>					dim_item
%type <arg_list>					arg_list
%type <function_definition>			sub_definition
%type <function_definition>			function_definition
%type <exprtype>					exprtype

%type <varref>						varref
%type <variable_assignment>			assigment

%type <if_clause>					if_clause
%type <while_loop>					while_loop

%type <call_function>				call_function_or_array

%%

program: lines tEOPROG {
			if(useDefautSubMain){
				debug("program ended\n");
				program = new DefaultMainFunctionAST( $1 );
			}else{
				program = $1;
				debug("module ended\n");
			}
			YYACCEPT;
		}
		| lines statements tEOPROG {

			debug("!!!no new line at the end of file!!!\n"); exit(1);
			if(useDefautSubMain){
				debug("program ended\n");
				program = new DefaultMainFunctionAST( $1 );
			}else{
				program = $1;
				debug("module ended\n");
			}
			YYACCEPT;			
		}
		;

lines: lines line {
					$$ = $1;
					if(!$1){
						$1 = $$ = new CodeBlockAST;
					}
					if($2){
						debug("addchine1 , %p %p %p\n",$$,$1,$2);
						$$->addchild($2);
					}else{
						debug("addchine1 voided , %p %p %p\n",$$,$1,$2);
					}
	}
	| line {
		$$ = 0;debug("addchine2\n");
		if($1){
			debug("addchine2 real\n");
			$$ = new CodeBlockAST; 	$$->addchild($1); 	}
	} ;

line: statements tNEWLINE { $$=$1;  }
	| statement tNEWLINE {
		if(!$1){debug("statement nil\n");}
		$$ = new StatementsAST ; $$->push_back(StatementASTPtr($1));
	}
	| tNEWLINE { debug("空行"); $$ = 0;}
	| call_function_or_array tNEWLINE {
		CallStmtAST * callstmt =  new CallStmtAST( $1 );
		$$ = new StatementsAST ;
		$$->push_back( StatementASTPtr(callstmt)  );
	}
	;

statements : statements ':' statement {  $$ = $1; $$->push_back(StatementASTPtr($3)); }
		| statement ':' statement {
				$$ = new StatementsAST ;
				$$->push_back(StatementASTPtr($1));
				$$->push_back(StatementASTPtr($3));
		}
		;

statement: printstatement { $$ = $1; }
		| tDIM dim_item { $$ = $2; }
		| assigment {$$= $1;}
		| tLET assigment { $$ = $2;}
		| tRETURN expression { $$ = new ReturnAST($2);}
		| if_clause {$$= $1;}
		| while_loop {$$= $1;}
		| sub_definition  {$$= $1;}
		| function_definition  {$$= $1;}
	//	| call_function_or_array ':'{ $$ = new CallStmtAST($1); }
	//	| tNEWLINE { $$= new EmptyStmtAST();}
		| expression ':' { /*TODO*/debug("here====3====\n"); exit(1);	}
		;


assigment: varref tEQU expression {
		VariableExprAST * varref = new VariableExprAST($1);
		$$ = new AssigmentAST(varref, $3);
	};

exprtype: tLONG	{
		$$ = new std::string("long");
	}
	| tSTR {
		$$ = new std::string("string");
	}
	| tID {
		debug("define as user type not supported\n");
		exit(1);
	};

printstatement:
	tPRINT  printinto  expression_list  {

		$3->Append( new EmptyExprAST );
		$$ = new PrintStmtAST( $2, $3 );
		
		debug("got print1 done\n");
	}
	|tPRINT printinto  expression_list ',' {
		$$ = new PrintStmtAST( $2, $3 );
	}
	|tPRINT  printinto  expression_list ';' {
		$$ = new PrintStmtAST( $2, $3 );
	}
	|tPRINT  printinto {
		ExprListAST * exprList = new ExprListAST;
		exprList->Append( new EmptyExprAST );
		$$ = new PrintStmtAST( $2, exprList );
	}
	;

printinto: '#' tInteger ','  { debug("print has got itger\n") ;}
	| /*empty*/	{  debug("empty printinto\n");	}
	;
	
expression_list: expression_list ',' expression { $$ = $1 ; $$->Append($3); }
	| expression {
		$$ =  new ExprListAST;
		$$->Append($1);
	}
	;

call_function_or_array:
		// 这个也是函数调用
		varref '('  ')' { $$ = new CallExprAST($1); debug("functioncall %s with no arg\n", $1->ID.c_str()); } 
		| varref  '(' expression_list ')' { 	 // 这个可能是函数调用, 也许是数组哦 :)
			 // 现在就当是函数调用了, 在后面的阶段再生成数组访问
			 debug("functioncall %s with  args!!!!\n" , $1->ID.c_str() );

			 $$ = new CallExprAST($1 , $3 );			
		}


	
expression: call_function_or_array
		| '(' expression ')'
		| expression '+' expression {   $$ = new CalcExprAST( $1, OPERATOR_ADD , $3 );  }
		| expression '-' expression {   $$ = new CalcExprAST( $1, OPERATOR_SUB , $3 );  }
		| expression '*' expression {   $$ = new CalcExprAST( $1, OPERATOR_MUL , $3 );  }
		| expression '/' expression {   $$ = new CalcExprAST( $1, OPERATOR_DIV , $3 );  }
		| expression tLTN expression {   $$ = new CalcExprAST( $1, OPERATOR_LESS , $3 );  }
		| expression tLEQ expression {   $$ = new CalcExprAST( $1, OPERATOR_LESSEQU , $3 );  }
		| expression tGTN expression {   $$ = new CalcExprAST( $1, OPERATOR_GREATER , $3 );  }
		| expression tGEQ expression {   $$ = new CalcExprAST( $1, OPERATOR_GREATEREQUL , $3 );  }

 		| varref	{
			//TODO the VariableRefExprAST
			$$ = new VariableExprAST( $1 );
			debug("do we got this?\n");			
		}
		| tInteger  {
			//常量
			$$ = new NumberExprAST( $1 );
		}
		| tNUMBER //浮点数
		| tSTRING { //字符串
			$$ = new StringExprAST($1);
		}
		;

varref:	varref '.' tID {
		debug("ref menber %s . %s , not supported yet\n", $1->ID.c_str()  , $3->c_str() );
		exit(1); // 逐级传递
	}// 成员变量
	| varref tDREF  tID  // 指针解引用
	| tID {
		// 变量的引用? 反正是一个标识符的引用,
		// 所以我构建一个标识符引用语句. 这个会被用来构建函数调用和数组语句以及变量.
		$$ = new ReferenceAST( $1 );
		debug("idref %s\n", $1->c_str());
	}
	;
	
seperator : tNEWLINE | ':' ;

//*****************************************/
//* 这里开始是函数和过程定义
//*****************************************/

function_definition: tFUNCTION tID '(' arg_list ')' tAS exprtype tNEWLINE
						lines
				tFUNCTIONEND {
					useDefautSubMain = false;
					$$ = new FunctionDimAST( *$2 , $4, *$7 );

					$$->body = CodeBlockASTPtr($9);
				}
				|tFUNCTION tID '(' arg_list ')' tNEWLINE
					lines
				tFUNCTIONEND {
					useDefautSubMain = false;
					$$ = new FunctionDimAST( *$2 , $4 , "long" ) ;

					$$->body = CodeBlockASTPtr($7);
				}
				;

sub_definition: tSUB  tID  '(' arg_list ')'
				lines
			tSUBEND {
				useDefautSubMain = false;
				debug("!!SUB %s defined with arg !!\n",$2->c_str());

				$$ = new FunctionDimAST( *$2,$4); //delete $2;				
				$6->parent = $4;
				$$->body = CodeBlockASTPtr($6);
			}
		  ;

arg_list:{ $$ = 0; }
	|arg_list ',' tID tAS exprtype {
		$$ = $1;
		$$->addchild( new ArgumentDimAST( *$3  , * $5 ) );

		debug("definning %s is type %p as arg\n",$3->c_str(), $5);

		debug("define multiple line is not supported yet\n");
		//exit(1);
	}
	| tID tAS exprtype {
		debug("definning %s is type %p as arg\n",$1->c_str(), $3);
		
		$$ = new ArgumentDimsAST ;
		$$->addchild(new ArgumentDimAST( *$1  , * $3 ));
	}
	;

dim_item: tID tAS exprtype {
		debug("definning %s is type %p\n",$1->c_str(), $3);
		$$ = new VariableDimAST( *$1  , * $3 );
	};


//*****************************************/
//* 这里开始是循环和控制语句支持
//*****************************************/

		//*****************************************/
		//* 条件控制语句
		//*****************************************/
if_clause: tIF expression tTHEN statement {
			// 单行 if then 语句
			$$ = new IFStmtAST( ExprASTPtr($2));
			$$->_then = CodeBlockASTPtr(new CodeBlockAST($4));
	}
	|	tIF expression tTHEN seperator
 			lines
		tENDIF {
			$$ = new IFStmtAST( ExprASTPtr($2));
			$$->_then = CodeBlockASTPtr($5);
		}
	|	tIF expression tTHEN seperator
 			lines
 		tELSE
			lines
		tENDIF  {
			$$ = new IFStmtAST( ExprASTPtr($2));
			$$->_then = CodeBlockASTPtr($5);
			$$->_else = CodeBlockASTPtr($7);
		}
;

		//*****************************************/
		//* While 循环语句
		//*****************************************/

while_loop: tWHILE expression seperator
			lines
		tENDWHILE {
			$$ = new WhileLoopAST( ExprASTPtr($2) , $4);
		};