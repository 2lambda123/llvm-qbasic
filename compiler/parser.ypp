/*
    Parser of QBASIC to build Abstruct Syntax Tree

    * Copyright (C) 2012  microcai <microcai@fedoraproject.org>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 3 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
%skeleton "lalr1.cc"
%define namespace qb

%{

/* Include main header file. */
#include "qbc.h"
#include "parser.hpp"
#include <boost/make_shared.hpp>
#include <boost/concept_check.hpp>

extern	StatementAST * program;

extern int yylex(qb::parser::semantic_type * yylval_param );

//extern int yylex_destroy(void);
//extern void yyerror (char *msg);
extern int yylineno;

#define debug printf
extern StatementAST * program;

/* Global variables. */
std::string current_function;  /* name of currently parsed function */
int in_loop = 0;                /* in loop? */

/* Local variables. */
int continue_corrections = 0;   /* continue corrections */
int unclosed_dos = 0;           /* unclosed "if" count */
int unclosed_fors = 0;          /* unclosed "for" count */
int unclosed_ifs = 0;           /* unclosed "if" count */
int unclosed_repeats = 0;       /* unclosed "repeat" count */
int unclosed_subs = 0;          /* unclosed subroutine count */
int unclosed_switches = 0;      /* unclosed "switch" count */
int unclosed_whiles = 0;        /* unclosed "while" count */
bool useDefautSubMain = false;	/* shall we treat the while file as an sub main ? */

void qb::parser::error(const parser::location_type& loc, const std::string& msg)
{
	std::cerr << msg << " at line " << yylineno << std::endl ;
	exit(1);
}

%}

%union {
	char *				string;         /* quoted string */
	std::string *		id;         /* general symbol */
	double 				number;        /* double number */
	long				integer;			/* long number */

	ReferenceAST*		varref;
	ExprAST*			expression;
	ExprListAST*		expression_list;

	PrintIntroAST*		printinto;
	
	
	ExprTypeAST *  		exprtype;
	NumberExprAST* number_expression;
    VariableRefExprAST*varable_ref;	

    PrintStmtAST*		printstatement;
	StatementAST* statement;
	StatementAST* statement_list;
	AssigmentAST*variable_assignment;
	IFStmtAST * if_clause;
	
	WhileLoopAST* while_loop;
	
	VariableDimAST*		dim_list;
	FunctionDimAST	 *function_definition;

	PrintIntroAST *print_intro;
	std::string 	*cppstring;
}

%token  tEOPROG

// 操作符
%left tOR
%left tAND
%right tNOT
%left tNEQ
%left tGEQ
%left tLEQ
%left tLTN
%left tGTN
%left tEQU
%left '-' '+'
%left '*' '/' tMOD
%right UMINUS UPLUS
%left tPOW

%nonassoc tDREF
%nonassoc '.'

//关键字

%token tAS
%token tSUB
%token tSUBEND

%token tFUNCTION
%token tFUNCTIONEND
%token tDIM tLET tPRINT

%token tNEWLINE

%token tIF tTHEN tENDIF tELSE tELSEIF
%token tWHILE tENDWHILE

// 内置数据类型
%token tLONG 

// 数据 , 标识符, 变量名, 函数名, 等等
%token <id>		tID
%token <integer> tInteger
%token <string>	tSTRING
%token <number> tNUMBER

%type <expression>					expression
%type <expression_list>				expression_list
%type <printinto>					printinto
%type <printstatement>				printstatement
%type <statement_list>				lines
%type <statement_list>				line
%type <statement_list>				statements
%type <statement>					statement
%type <dim_list>					dimlist
%type <function_definition>			subdefine
%type <exprtype>					exprtype

%type <varref>						varref
%type <variable_assignment>			assigment

%type <if_clause>					if_clause
%type <while_loop>					while_loop
%%

program: lines tEOPROG {
			if(useDefautSubMain){
				debug("program ended\n");
				//program = new DefaultMainFunctionAST( $1 );
			}else{
				program = $1;
				debug("module ended\n");
			}
			YYACCEPT;
		}
		| lines statements tEOPROG {

			debug("!!!no new line at the end of file!!!\n"); exit(1);
			if(useDefautSubMain){
				debug("program ended\n");
				//program = new DefaultMainFunctionAST( $1 );
			}else{
				//program = $1;
				debug("module ended\n");
			}
			YYACCEPT;
			
		}
		;

lines: lines line { $$ = $1; $$->addchild($2); }
	| line {
		$$ = new StatementAST;
		$$->addchild($1);
	} ;

line: statements tNEWLINE { $$=$1 ;}
	| expression tNEWLINE { /*TODO*/debug("here====5====\n"); exit(1);	}
	| tNEWLINE { $$= new EmptyStmtAST();}
	;

statements : statements ':' statement { /*TODO*/debug("here====2====\n"); exit(1);	}
		| statement {$$= $1;}
		| if_clause
		| while_loop
		| subdefine {$$= $1;}
		| function_definition { /*TODO*/debug("here====2====\n"); exit(1);	}
		| expression ':' { /*TODO*/debug("here====2====\n"); exit(1);	}
		;

statement: printstatement { $$ = $1; }
		| tDIM dimlist { $$ = $2; }
		| assigment {$$= $1;}
		| tLET assigment { $$ = $2;}
		;
		
function_definition: tFUNCTION tID '(' dimlist ')' tAS exprtype
				lines
				tFUNCTIONEND
			|tFUNCTION tID '(' dimlist ')' // default type , int
				lines
				tFUNCTIONEND
			;

subdefine: tSUB  tID '(' ')'
				lines
			tSUBEND {
				$$ = new FunctionDimAST( *$2 ); //delete $2;

				$$->body = StatementASTPtr($5);
				
				debug("!!SUB %s defined!!\n",$2->c_str());
			}
		| tSUB  tID '(' dimlist ')'
				lines
			tSUBEND {
				$$ = new FunctionDimAST( *$2 ); //delete $2;

				$$->body = StatementASTPtr($6);

				debug("!!SUB %s defined with args !!, but not supported yet\n",$2->c_str());
				exit(0);
			}
		  ;

assigment: varref tEQU expression {
		VariableRefExprAST * varrefast = new VariableRefExprAST( ReferenceASTPtr($1) );
		$$ = new AssigmentAST(VariableRefExprASTPtr(varrefast), ExprASTPtr($3));
	};

exprtype: tLONG	{
	$$ = new NumberTypeAST;
	}
	| tID {
		debug("define as user type not supported\n");
		exit(1);
	};

dimlist: dimlist ',' tID tAS exprtype { debug("define multiple line is not supported yet\n");exit(1);}
	| tID tAS exprtype {
		debug("definning %s is type %p\n",$1->c_str(), $3);
		$$ = new VariableDimAST( *$1  , ExprTypeASTPtr ( $3 ));
	}
	;

printstatement :
	tPRINT  printinto  expression_list  {

		$3->Append( new EmptyExprAST );
		$$ = new PrintStmtAST( $2, $3 );
		
		debug("got print1 done\n");
	}
	|tPRINT printinto  expression_list ',' {
		$$ = new PrintStmtAST( $2, $3 );
	}
	|tPRINT  printinto  expression_list ';' {
		$$ = new PrintStmtAST( $2, $3 );
	}

	;

printinto: '#' tInteger ','  { debug("print has got itger\n") ;}
	| /*empty*/	{  debug("empty printinto\n");	}
	;
	
expression_list: expression_list ',' expression { $$ = $1 ; $$->Append($3); }
	| expression {
		$$ =  new ExprListAST;
		$$->Append($1);
	}
	;

expression:
		| varref '('  ')' { debug("functioncall with no arg\n");} // 这个也是函数调用
		| varref  '(' expression_list ')' // 这个可能是函数调用, 也许是数组哦 :)
		 '(' expression ')'
		| expression '+' expression {   $$ = new CalcExprAST( $1, OPERATOR_ADD , $3 );  }
		| expression '-' expression {   $$ = new CalcExprAST( $1, OPERATOR_SUB , $3 );  }
		| expression '*' expression {   $$ = new CalcExprAST( $1, OPERATOR_MUL , $3 );  }
		| expression '/' expression {   $$ = new CalcExprAST( $1, OPERATOR_DIV , $3 );  }
		| expression tLTN expression {   $$ = new CalcExprAST( $1, OPERATOR_LESS , $3 );  }
		| expression tLEQ expression {   $$ = new CalcExprAST( $1, OPERATOR_LESSEQU , $3 );  }
		| expression tGTN expression {   $$ = new CalcExprAST( $1, OPERATOR_GREATER , $3 );  }
		| expression tGEQ expression {   $$ = new CalcExprAST( $1, OPERATOR_GREATEREQUL , $3 );  }

 		| varref	{
			//TODO the VariableRefExprAST
			$$ = new VariableRefExprAST( ReferenceASTPtr($1) );
			debug("do we got this?\n");			
		}
		| tInteger  {
			//常量
			$$ = new ConstNumberExprAST( $1 );
		}
		| tNUMBER //浮点数
		;

varref:	varref '.' tID { debug("ref menber %s . %s , not supported yet\n", $1->ID.c_str()  , $3->c_str() ); 			exit(1); // 逐级传递
	}// 成员变量
	| varref tDREF  tID  // 指针解引用
	| tID {
		// 变量的引用? 反正是一个标识符的引用,
		// 所以我构建一个标识符引用语句. 这个会被用来构建函数调用和数组语句以及变量.
		$$ = new ReferenceAST( $1 );
		debug("idref %s\n", $1->c_str());
	}
	;
	
seperator : tNEWLINE | ':' ;

//*****************************************/
//* 这里开始是循环和控制语句支持
//*****************************************/

		//*****************************************/
		//* 条件控制语句
		//*****************************************/
if_clause: tIF expression tTHEN statement {
			// 单行 if then 语句
			$$ = new IFStmtAST( ExprASTPtr($2));
			$$->_then = StatementASTPtr($4);
			$4->parent = $$;
	}
	|	tIF expression tTHEN seperator
 			lines
		tENDIF {
			$$ = new IFStmtAST( ExprASTPtr($2));
			$$->_then = StatementASTPtr($5);
			$5->parent = $$;
		}
	|	tIF expression tTHEN seperator
 			lines
 		tELSE
			lines
		tENDIF  {
			$$ = new IFStmtAST( ExprASTPtr($2));
			$$->_then = StatementASTPtr($5);
			$5->parent = $$;
			$$->_else = StatementASTPtr($7);
			$7->parent = $$;
		}
;

		//*****************************************/
		//* While 循环语句
		//*****************************************/

while_loop: tWHILE expression seperator
			lines
		tENDWHILE {
			$$ = new WhileLoopAST( ExprASTPtr($2) , StatementASTPtr($4));
			$4->parent = $$;
		};