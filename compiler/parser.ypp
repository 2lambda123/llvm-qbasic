/*
    Parser of QBASIC to build Abstruct Syntax Tree
    * Copyright (C) 2009-2010 Thomas Larsen and Pedro Sá.
	* Copyright (C) 1995-2005 Marc-Oliver Ihm.
    * Copyright (C) 2012  microcai <microcai@fedoraproject.org>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 3 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/
%skeleton "lalr1.cc"
%define namespace qb

%{

/* Include main header file. */
#include "qbc.h"
#include "parser.hpp"
#include <boost/make_shared.hpp>
#include <boost/concept_check.hpp>

extern	StatementAST * program;

extern int yylex(qb::parser::semantic_type * yylval_param );

//extern int yylex_destroy(void);
//extern void yyerror (char *msg);
extern int yylineno;

#define debug printf
extern StatementAST * program;

/* Global variables. */
std::string current_function;  /* name of currently parsed function */
int in_loop = 0;                /* in loop? */

/* Local variables. */
int continue_corrections = 0;   /* continue corrections */
int unclosed_dos = 0;           /* unclosed "if" count */
int unclosed_fors = 0;          /* unclosed "for" count */
int unclosed_ifs = 0;           /* unclosed "if" count */
int unclosed_repeats = 0;       /* unclosed "repeat" count */
int unclosed_subs = 0;          /* unclosed subroutine count */
int unclosed_switches = 0;      /* unclosed "switch" count */
int unclosed_whiles = 0;        /* unclosed "while" count */
bool useDefautSubMain = false;	/* shall we treat the while file as an sub main ? */

void qb::parser::error(const parser::location_type& loc, const std::string& msg)
{
	std::cerr << msg << " at line " << yylineno << std::endl ;
	exit(1);
}

%}

%union {
	char *				string;         /* quoted string */
	std::string *		id;         /* general symbol */
	double 				number;        /* double number */
	long				integer;			/* long number */

	ReferenceAST*		varref;
	ExprAST*			expression;
	ExprListAST*		expression_list;

	PrintIntroAST*		printinto;
	
	
	ExprTypeAST *  		exprtype;
	NumberExprAST* number_expression;
    VariableRefExprAST*varable_ref;	

    PrintStmtAST*		printstatement;
	StatementAST* statement;
	StatementAST* statement_list;
	AssigmentAST*variable_assignment;
	IFStmtAST * if_clause;
	
	WhileLoopAST* while_loop;
	
	VariableDimAST*dim_list;
	FunctionDimAST	 *function_definition;

	PrintIntroAST *print_intro;
	std::string 	*cppstring;
}

%token  tEOPROG

// 操作符
%left tOR
%left tAND
%right tNOT
%left tNEQ
%left tGEQ
%left tLEQ
%left tLTN
%left tGTN
%left tEQU
%left '-' '+'
%left '*' '/' tMOD
%right UMINUS UPLUS
%left tPOW

%nonassoc tDREF
%nonassoc '.'

//关键字

%token tAS
%token tSUB
%token tSUBEND

%token tFUNCTION
%token tFUNCTIONEND
%token tDIM tLET tPRINT

%token tNEWLINE


// 内置数据类型
%token tLONG 

// 数据 , 标识符, 变量名, 函数名, 等等
%token <id>		tID
%token <integer> tInteger
%token <string>	tSTRING
%token <number> tNUMBER

%type <varref>						varref
%type <expression>					expression
%type <expression_list>				expression_list
%type <printinto>					printinto
%type <printstatement>				printstatement
%type <statement_list>				lines
%type <statement_list>				line

%type <function_definition>			subdefine

%%

program: lines tEOPROG {
			if(useDefautSubMain){
				debug("program ended\n");
				//program = new DefaultMainFunctionAST( $1 );
			}else{
				program = $1;
				debug("module ended\n");
			}
			YYACCEPT;
		}
		| lines statements tEOPROG {

			debug("!!!no new line at the end of file!!!\n"); exit(1);
			if(useDefautSubMain){
				debug("program ended\n");
				//program = new DefaultMainFunctionAST( $1 );
			}else{
				//program = $1;
				debug("module ended\n");
			}
			YYACCEPT;
			
		}
		;

lines: lines line { $$ = $1; $$->addchild($2); }
	| line {
		$$ = new StatementAST;
		$$->addchild($1);
	} ;

line: statements tNEWLINE { debug("here=====2===\n");	}
	| statements expression tNEWLINE { debug("here==3======\n");	}
	| expression tNEWLINE { debug("here====5====\n");	}
	| tNEWLINE { $$= new EmptyStmtAST(); debug("here=====1===\n");	}
	;

statements : statements ':' statement
		| statement
		| subdefine
		| function_definition
		| expression ':'
		;

statement : printstatement
		| tDIM dimlist
		| assigment
		;
		
function_definition: tFUNCTION tID '(' dimlist ')' tAS type
				lines
				tFUNCTIONEND
			|tFUNCTION tID '(' dimlist ')' // default type , int
				lines
				tFUNCTIONEND
			;

subdefine: tSUB  tID '(' ')'
				lines
			tSUBEND {
				$$ = new FunctionDimAST( *$2 ); //delete $2;

				$$->body = StatementASTPtr($5);
				
				debug("!!SUB %s defined!!\n",$2->c_str());
			}
		| tSUB  tID '(' dimlist ')'
				lines
			tSUBEND {
				$$ = new FunctionDimAST( *$2 ); //delete $2;

				$$->body = StatementASTPtr($6);

				debug("!!SUB %s defined with args !!, but not supported yet\n",$2->c_str());
				exit(0);
			}
		  ;

assigment: varref tEQU expression
		| tLET varref tEQU expression
		;

type: tLONG | tID ;

dimlist: dimlist ',' tID tAS type
	| tID tAS type
	;

printstatement :
	tPRINT  printinto  expression_list  {

		$3->Append( new EmptyExprAST );
		$$ = new PrintStmtAST( $2, $3 );
		
		debug("got print1 done\n");
	}
	|tPRINT printinto  expression_list ',' {
		$$ = new PrintStmtAST( $2, $3 );
	}
	|tPRINT  printinto  expression_list ';' {
		$$ = new PrintStmtAST( $2, $3 );
	}

	;

printinto: '#' tInteger ','  { debug("print has got itger\n") ;}
	| /*empty*/	{  debug("empty printinto\n");	}
	;
	
expression_list: expression_list ',' expression
	| expression {
		$$ =  new ExprListAST;
		$$->Append($1);
	}
	;

expression:
		| varref '('  ')' { debug("functioncall with no arg\n");} // 这个也是函数调用
		| varref  '(' expression_list ')' // 这个可能是函数调用, 也许是数组哦 :)
		| varref  
		 '(' expression ')'
		| expression '+' expression
		| expression '-' expression
		| expression '*' expression
		| expression '/' expression
		| tInteger  {
			//常量
			$$ = new ConstNumberExprAST( $1 );
		}
		| tNUMBER //浮点数
		;

expression_list : expression_list ',' expression
			| expression
			;

varref:	varref '.' tID { debug("ref menber %s . %s , not supported yet\n", $1->ID.c_str()  , $3->c_str() ); exit(1); }// 成员变量
	| varref tDREF  tID  // 指针解引用
	| tID {
		// 变量的引用? 反正是一个标识符的引用,
		// 所以我构建一个标识符引用语句. 这个会被用来构建函数调用和数组语句以及变量.
		$$ = new ReferenceAST( $1 );
		debug("idref\n");
	}
	;