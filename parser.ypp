/*
    Parser of QBASIC to build Abstruct Syntax Tree
    Copyright (C) 2012  microcai <microcai@fedoraproject.org>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/

%{


#include <stdio.h>
#include <boost/shared_ptr.hpp>
#include <boost/make_shared.hpp>

#include "ast.h"
    
AST *programBlock; /* the top level root node of our final AST */

extern int yylex();
void yyerror(const char *s) { printf("ERROR: %s\n", s); }


inline void addtail(StatementAST* l,StatementAST* p) {
	AST* _p =l;//->next;//.get() ;
	while(_p->next)//.get())
		_p = _p->next.get();
	_p->next.reset(p);
}

%}

%union {
	AST *ast;
	StatementAST *stmt;
	PrintAST * printstmt;
	FunctionParameterListAST	*parameterlist;
	VariableRefExprAST * var;
	ExprAST* expr;
	ConstExprAST *numeric;
	std::string* string;
	int token;
}

/* Define our terminal symbols (tokens). This should
   match our tokens.l lex file. We also define the node type
   they represent.
 */

%token <string> TIDENTIFIER TINTEGER TDOUBLE
%token <token> TQBEQUAL TQBNOTEQUAL  TQBLESS TQBLESSEQU TQBGREATER TQBGREATEREQU
%token <token> TQBNOT TQBAND
%token <token> TPRINT
%token <token> IF THEN ELSE ENDIF LET
%token <token> NEWLINE WHITESPACE TEOF


/* Define the type of node our nonterminal symbols represent.
   The types refer to the %union declaration above. Ex: when
   we call an ident (defined by union type ident) we are really
   calling an (NIdentifier*). It makes the compiler happy.
 */

%type <ast> program
%type <stmt> stmts
%type <stmt> stmt 
%type <stmt> letstmt
%type <printstmt> printstmt
%type <parameterlist> printlist
%type <numeric> numeric
%type <var> var
%type <expr> expr
/* Operator precedence for mathematical operators */
%left TPLUS TMINUS
%left TMUL TDIV

%start program

%%

program : stmts { programBlock = $$ = $1; }
        ;

stmts : stmt 
    | stmt stmts  {
		$1->next.reset($2);
		$$ = $1;
	}
	;

stmt : letstmt 
	| printstmt
	| NEWLINE { $$ = new StatementAST(); }
     ;

letstmt : [LET] var TQBEQUAL expr NEWLINE {
		$$ = new LetStatementAST( VariableRefExprASTPtr($1) , ExprASTPtr($3) ) ;
	}
	;

expr: expr WHITESPACE TPLUS WHITESPACE expr { ; }
	| numeric { ;}
	;

printstmt : TPRINT WHITESPACE printlist NEWLINE {
		$$ = new PrintAST(*$3);
	}
	;

printlist : numeric {
		$$ = new FunctionParameterListAST ;
		$$->push_back( ExprASTPtr( $1 ) );
	}
	| printlist WHITESPACE numeric { $1->push_back( ExprASTPtr ( $3) );  }
	;

var : 	TIDENTIFIER { }
	;

numeric: 	TINTEGER { $$ = new ConstExprAST($<string>1); delete $1; }
	;